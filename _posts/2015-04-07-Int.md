---
layout: post
title: 计算机网络总结
category: Technology
description: 大体总结了这学期计算机网络的知识要点。
---
#1. 计算机网络分层协议
有哪些系统也是分层（layer）结构？   
计算机存储结构，不过还是不同的，不会有功能调用。   
课本举例，航空系统。

##1.1 协议栈
各层的协议总和称为协议栈    
>
1. 应用层(Application-layer)
    - HTTP：Web文档
    - SMTP：E-Mail
    - FTP:文件
    - DNS：域名系统
    - 分组名称：`Message`，主机程序与主机程序之间
2. 运输层(Transportation-layer)
    - TCP
    - UDP
   - 分组名称：`Segment`，程序之间
3. 网络层(Network-layer)
    - IP
    主机之间
4. 链路层(Link-layer)
    - DOCSIS
	- 分组名称：`frame`，路由器路由(名字好奇怪--)
5. 物理层 
    - 比特流:`bits`
    - 结点(这是什么？)
    
*tip:最初设计其实有七层，在应用层之后，运输层之前：表示层和回话层（是什么）,相应功能，如果需呀，就靠开发者自己了。*
    
concept:
封装:下一次把上一次的信息封装起来。包起来。  
分组：首部字段和有效负载字段(playload layer)

##1.2 下面是坏家伙如何攻击网络时间：

>1. 放入有害程序
2. DoS(Denial-of-Service)攻击 
	a. 弱点攻击
	b. 带宽泛洪
	c. 连接泛洪
3. 嗅探分组

计算机网络是一个基于相互信任的系统。

#2. 应用层
我们平时用网络做什么？web浏览网页，qq聊天，看视频，发邮件，发文件

1. 应用程序
	- 社交软件
	- 文件传输
2. 浏览器 
	资讯、邮箱、搜索
3. 游戏
	实时在线游戏

等等。  不过彼此功能有交叠。 网页也可以进行聊天看视频等应用程序所做的事。

##2.1 应用程序体系结构：
>- C/S   
- P2P

##2.2 进程通信
*而不是应用通信-->`What is pocess?`*   

如何区分客户端和服务端：
>	Client: 发起通信的进程

>	Server: 等待联系的进程

其实和生活中是一样的，一个餐厅提供服务，只有你去了，你发起想要在那吃饭的信息，它才开始为你提供服务。   
可不可以一对多呢？进程一定要是一对一吗？作为服务器是不是很可能要   
多对多，那么是怎么实现的呢？是有多个进程吗？

>每一个进程通过socket(套接字)向网络发送和接受message(报文)

socket就像是，恩，怎么说呢，代理的商人吗？或者说是，邮局？你们彼此之间写信时，为你们传递信。因为有需求的人多嘛，所以就统一起来。好像不对也，书上说，进程是房子，套接字就是门，真心不理解为什么翻译成套接字，那么拗口难理解。自己说进程与网络之间的门多好。    
网络那么的错综复杂，它怎么知道我这data是发给谁的呢？就算是发到了，又怎么知道是哪一个进程的呢？wow，好复杂的系统。
		
`API：Application Programing Interface` 啊，就是应用程序这座房子的，各种门各种窗外咯
	
开发者能使用API，却几乎不能控制API。就是说，你直接用啊，我给你一支笔，你不需要知道笔怎么制作的，怎么能写出字，你直接用来写字就好了嘛。    
开始说怎么确定地址了。恩,好好看看。

##2.3. 进程寻址
>主机地址  
主机内的进程标识
	
你家是哪个小区?是小区的哪户？
这个可以，找门（Socket）嘛，就照门牌号来找。

>主机-->IP 地址（32bit）	
进程-->port number( 端口号 )   
web:80   
SMTP：25   
[More](www.iana.org)

##2.4 可提供程序使用的运输服务
来，我们来选交通方式。

- **可靠不可靠**（能不能都到达）：能不能安全把信都送到，而不是半路掉了一些
- **吞吐量**（一次能运输多少）：交付bit的输入，就是我一次能给你多少信咯，你要是一个人来，最多也就提两麻袋吧，要是卡车的话，啊，那就不一样了。

	对吞吐量有要求的程序：`带宽敏感程序`，你要是不能每次拿一定的数量走的话，我就不能和你愉快玩耍了。说话的时候，你只能接受半句话，那要怎么理解呢？还不如直接不接收。    

	有的应用程序说，好吧，我要求不高，你有多少我就传多少吧。这叫`弹性应用`

- **定时**（要多少时间才能到）
		 交互式实时应用
- **安全性 **
	加密-解密

说了那么多结果只有两种运输协议，TCP/UDP，现实生活中就不一样了，有汽车、火车、高铁、地铁、飞机......

###2.4.1 TCP Server
TCP: Transmission Contral Protocol

- 面向连接的服务：就是指，在我们正式传输数据之前，我们先相互打个招呼，握握手，准备好接下来的交流。`全双工`:好难听的翻译对不对？其实就是双方可以同时传Message。
- 可靠数据传输服务：无错、按序。是不是很可靠？
 它还有拥塞控制机制，还有交警先生。
		
*补充：安全性从何而来？*

加强型TCP，没错就是Secoure Socket Layer（= =什么鬼），别急，简称你一定见过，`SSL`。它有，加密、数据完整性和**端点识别**（*这是什么？*）SSL在应用程序和TCP套接字之间，进行加密和解密。（SSL在喊*I'am a mistery box.*）
###2.4.2 UDP Sever
UDP: User Data Protocal

它很轻，对就是很不靠谱。不握手打招呼、不提供可靠数据传输、不保证顺序，当然更没有拥塞控制了。   
如此不靠谱的运输协议，为什么还会存在这个世界上！！？？   
当然还是有用的。像QQ，就是使用的UDP服务。   
UDP没有拥塞控制，可以选定速率向网络层注入数据。

##2.5 应用层协议
网络应用的一部分，但也是很重要的一部分。   
定义主机应用程序之间如何传递Message。

###2.5.1 网络应用:
#### 1. WWW: World Wide Web
- 特点：按需操作，C/S 架构。    
- 组成：Web页面由object组成，HTML文档是一个object，一张图片也是一个object。
- 协议：HTTP(HyperText Transfer Protocol)，由TCP支撑。
- 性质：它是无状态协议(stateless protocol)，即不保存关于用户的任何信息。那是如何记住我怎么实现？Cookie
- 分类：
持续和非持续连接  
持续：同一个TCP   
非持续：每个单独有一个TCP    
非持续连接每一个对象都有单独建立连接再传输

**RTT**：往返时间（Round-Trip Time）

非连续开始连接，需要两个RTT。连续可以连接节省时间。*但是连续是串行的，非连续是并行的，服务器有能力的话，并行不是会更快吗？这值得思考。可实际却使用的是流水线的连续连接。*
#### 2. 文件传输，**FTP**：两个TCP	一个控制，一个传输
#### 3. 邮件系统，其中包括用户代理、邮件代理和**SMTP**
- 特点：推协议
- 对比：HTTP是拉协议     

 *`注意：取邮件是拉，不能用SMTP，用POP3还有IMAP`*
#### 4. P2P
**实现原理**: 我为人人，人人为我。


#3. 运输层
- 运输层：进程之间的通信
- 网络层：主机间的通信

**如何确定给哪个进程？**    
套接字会分配端口号，如果是周知端口号，必须手动分配特定值，比如Web是80；如果不是，可以任其自动分配端口号。

> - UDP套接字标识：<目的IP，目的端口号>                          无连接的多多
 - TCP套接字标识：<源IP，源端口号，目的IP，目的端口号>    面向连接的多多

选择：拥塞控制（传输数据限制）、时间开销

其实也可以在应用程序中实现拥塞控制，同时使用UDP，这样就不会被限制。
还有现在也有研发出数据源自适应的拥塞控制，也就解决了UDP可能的问题。
##3.1 多路分解、多路复用
主机和进程之间的segment分发和收集
虚拟电路的实现通过复用。复用的复就是多的意思，实现多条虚拟电路咯。
>	
- FDM：frequency-Division Multiplexing) 频分复用。
- TDM：Time-Division Multiplexing 时分复用

比较两者 
##3.2可靠数据传输原理
什么是可靠数据传输？  
在可靠信道中，传输的数据**不会损坏**、**丢失**，并且都是**按序到达**。

运输层为应用层提供可靠信道，进行可靠数据传输（对应服务TCP）  
而网络层为运输层提供的是不可靠信道（对应服务IP）
### 3.2.1可靠数据传输协议(reliable transfer protocol)
我们在此只讨论单向数据传输。
####1. rdt 1.0
双方之间，通过完全可靠的信道进行数据传输。所以没什么需要做的。发送方调用：发送、分组打包、分组发送函数；接收方调用，接收、接收分组、传递函数。基本上就是不需要做什么事情。(应用层对运输层使用TCP就是这样的)    
FSM：finite-State Mashine
####2. rdt 2.0
好，现在假设都能按序到达，但是数据可能受损。   
自动重传请求协议(Automatic Repeat reQuest, `**ARQ**`): 接收方进行肯定确认或者否定确认。
>
1. 差错检验
2. 接收方反馈
3. 重传 1 ACK(肯定确认) 0 NAK(否定确认)

发送方停等协议（stop－and－wait）:在上一个分组被确认之前，不接收上层的send()      
问题在于ACK或者NAK受损了怎么办？ 重新传。那么接收方怎么知道得到的分组是新的，还是重复的？分组编号。是不是在重传，一个bit就够了。pkt1 pkt2
####3. rdt 2.1 NAK ACK
####4. rdt 2.2 1,0
分组或者ACKNAK流失了怎么办？怎么知道。装个计时器。
####5. rdt 3.0 timer 定时器
###3.3 网络中的网络: ISP层层叠叠

###`运输时间延误`：
>
1. 结点处理时延(检查首部，决定去向，差错检验）
2. 排队时延：在缓冲中，等待传出的时间
3. 传输时延：将分组所以比特推向链路所需时间，L/R L是指分组长度，R是指传输速率(b/s) 此时分组长度不可忽略
4. 传播时延：从链路起点到路由器的时间，d/s s是物理媒介传播速度，d是距离， 此时分组长度相对于d很小，可以看作是一个点。

La/R不可以大于1 


`吞吐量`
是以**接收方速率**来定义的。瞬时吞吐量、平均吞吐量。    
瓶颈链路 一根各个地方粗细不均的管子，速率就是管子最细的地方。然而中间其实很粗，所以限制的就是接入网，也就是你连入的第一个路由器接受速率。（一个服务器一个客户端）  
多个服务器，多个客户端。进和出口比中间的管子大。限制就是中间了。
画图讲解。


    





